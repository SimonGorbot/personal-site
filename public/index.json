
[{"content":"Hi I\u0026rsquo;m Simon \u0026#x1f44b;, a senior studying Mechatronics @ the University of Waterloo. I like writing firmware (in rust\u0026#x1f980;) and designing PCBs for robots\u0026#x1f916; and green-techüå≥.\nI\u0026rsquo;m currently working on an Open-Source humanoid hand ü¶æ\nLooking for new grad opportunities.\nFeatured Projects Safe Sensor Drivers Using Rust's Type System Rust Embedded Using the typestate design pattern with Rust\u0026rsquo;s compiler to enforce proper hardware configuration. SiTerm: Embedded Development Tool Rust Embedded WIP A TUI+Adapter that allows you to interface your laptop via USB to downstream systems and transfer serial messages using I2C, SPI, and UART. ","date":"10 October 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"10 October 2025","externalUrl":null,"permalink":"/tags/embedded/","section":"Tags","summary":"","title":"Embedded","type":"tags"},{"content":" Here\u0026rsquo;s a collection of some of the projects I\u0026rsquo;ve worked on in my free time, as well as some work I can talk about. ","date":"10 October 2025","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"","date":"10 October 2025","externalUrl":null,"permalink":"/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"This is still very much so a work in progress. I\u0026rsquo;m really trying to find time to work on it between classes and capstone. Never the less, here\u0026rsquo;s some info about the project so far:\nEverything is programmed in Rust. I\u0026rsquo;m using ratatui.rs to cook up my tui. The MCU I\u0026rsquo;m using as the adapter is the RP2040-Zero board from WaveShare I picked this board specifically because it\u0026rsquo;s tiny, has USB-C, all the peripherals necessary, and the potential to do something cool with PIO. Once all the code is complete I might make a shield for even easier connections to downstream embedded systems. I\u0026rsquo;m using the Embassy framework for my firmware The name of the project comes from an abbreviated form of Serial Interface Terminal. It\u0026rsquo;s also the first two letters of my name Simon Terminal. There\u0026rsquo;s a lot of unused code in the project currently because I started from a template. I\u0026rsquo;m in the process of trimming all of it out. SimonGorbot/SiTerm A development tool for quick debugging and testing of serial communication devices. Uses a TUI based serial monitor and writer to interact with a micro-controller to easily perform simple protocol actions and echo results. Rust 0 0 ","date":"10 October 2025","externalUrl":null,"permalink":"/projects/siterm/","section":"Projects","summary":"A TUI+Adapter that allows you to interface your laptop via USB to downstream systems and transfer serial messages using I2C, SPI, and UART.","title":"SiTerm: Embedded Development Tool","type":"project"},{"content":"","date":"10 October 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"10 October 2025","externalUrl":null,"permalink":"/tags/wip/","section":"Tags","summary":"","title":"WIP","type":"tags"},{"content":" Background In our final year of engineering at the University of Waterloo, students form groups to create a project over the span of 8-months that is meant to apply the knowledge and skills learned in the classroom and on co-op work terms. Since my four group mates and I have benefited so much from the open-source hardware community, we decided we want to contribute to the space. We‚Äôre building a fully open-source 16DOF/8DOA humanoid hand with integrated force sensing that will help give research labs and smaller robotics companies access to a high quality hardware platform to interact with the world built for human hands. We‚Äôve dubbed the project ‚ÄúBanana Hand‚Äù. Why? Because we all like bananas.\nThis project is still very much so a work in progress and will be for quite a while. I\u0026rsquo;ll be updating progress in a weekly dev log here if you\u0026rsquo;re interested: coming soon\nMy Contribution To The Team I will be primarily focused on writing the firmware for the hand (in Rust) as well as the design of all electrical sub-systems.\nProblem Statement Grasping remains one of the hardest unsolved problems in robotics, as it underpins a robot‚Äôs ability to interact with the human world. Yet researchers lack access to a humanoid hand that is affordable, proportional, robust, and well-documented.\nThrough conversations with many different robotics researchers at multiple universities, we learned that most researchers are interested in human-like robotic grasping, however, almost all turn away from solving the problem because of the high barrier to entry. On one end, the most accurate commercial robot hand solutions with the appropriate dexterity and force sensing are massively out of their price range. On the other end, the more affordable options are fragile and often create more headache than contribution to their research. Across this landscape, no option provides the right combination of accessibility, proportional design, sensing capability, and usability. This leads to many researchers settling for basic off-the-shelf two-fingered or 3-fingered grippers, which are extremely limited in human-like object manipulation, force sensing feedback, and grasping complex objects such as power tools and cooking utensils. Without a practical platform to explore dexterous robotic manipulation, academic labs, startups, and industry researchers are forced to abandon the problem ‚Äî a major bottleneck for progress in humanoid robotics and embodied AI.\nMeanwhile, industry leaders are investing heavily in humanoid robotics ‚Äî for example, Figure AI has raised over $1 billion at a $39 billion valuation to accelerate development of general-purpose humanoids. This underscores the importance and urgency of the field, yet outside of these highly funded efforts, academic labs and startups are left without practical tools for studying dexterous manipulation.\nIf developments in the robotics scene are moving towards integrating robots into everyday life to save people time and energy, then accessible human-like multipurpose grasping is a problem that absolutely must be solved.\nOur Solution Our team is developing an open-source humanoid hand that combines proportional design, dexterity, tactile sensing, and affordability ‚Äî attributes that existing solutions fail to deliver in a single platform. The hand is designed to perform the five fundamental human grips (pinch, tripod, hook, cylindrical, spherical), making it a versatile tool for studying real-world manipulation.\nThe hand will balance complexity and accessibility with 16 degrees of freedom and 8 actuated joints, enabling human-like motion without excessive size or cost. This includes a dexterous thumb, a dexterous index finger, and powerful grip from the latter 3 fingers, to maximize versatility and strength in a diverse range of applications. Integrated force sensing in the fingertips and palm will provide both touch detection and localized force feedback, allowing researchers to achieve more precise, closed-loop control during grasping tasks.\nAll design files ‚Äî including CAD, firmware, ROS2 integration, and testing protocols ‚Äî will be released under an open-source license, ensuring that researchers can both use and extend the platform. By targeting a cost of $2k‚Äì3k and leveraging accessible fabrication methods, the project lowers the barrier to entry for labs, startups, and industry researchers who want to explore dexterous robotic manipulation.\nHow does our solution improve on existing technologies or fill a void in the marketplace? Existing humanoid hands each succeed in one or two areas but fall short in others. High-end options like the Shadow Hand achieve excellent dexterity but cost nearly $100,000 and require large forearms, making them inaccessible to most researchers. Mid-tier open-source solutions such as the ORCA Hand ($8,000) provide dexterity but remain bulky and lack tactile sensing. The Leap Hand is more affordable but compromises proportionality and omits sensing, while ultra-low-cost options like the Amazing Hand ($250) are mechanically simple and unsuitable for serious research due to limited functionality and robustness.\nOur solution fills this gap by combining four attributes that have never been offered together:\nAffordability: A target cost of $2‚Äì3k, an order of magnitude less than high-end systems. Proportionality: Human-like kinematics that make interaction with everyday objects realistic. Dexterity: Support for the five fundamental grips with 16 DoF / 8 actuated joints. Tactile Sensing: Force feedback in both the fingertips and palm for closed-loop control. By uniting these features in an open-source platform, our hand becomes the first practical, community-driven research tool for humanoid grasping. It lowers the barrier to entry for labs, startups, and industry researchers, filling a critical void in the marketplace between prohibitively expensive commercial products and under-powered hobbyist models.\n","date":"5 August 2025","externalUrl":null,"permalink":"/projects/banana_hand/","section":"Projects","summary":"An open-source humanoid hand that combines proportional design, dexterity, tactile sensing, and affordability.","title":"BananaHand: Open Source Anthropomorphic Robotic Hand","type":"project"},{"content":"","date":"5 August 2025","externalUrl":null,"permalink":"/tags/kicad/","section":"Tags","summary":"","title":"KiCAD","type":"tags"},{"content":"","date":"5 August 2025","externalUrl":null,"permalink":"/tags/robotics/","section":"Tags","summary":"","title":"Robotics","type":"tags"},{"content":" Background During my previous internship at Fourier, I started my Embedded Rust development journey. I had previously written small amounts of Rust, but I would by no means say I knew the language at the time. One of Fourier\u0026rsquo;s embedded systems engineers is a very passionate Embedded Rust developer. He is the one who introduced to the Typestate pattern.\nThe typestate pattern is an API design pattern that encodes information about an object‚Äôs run-time state in its compile-time type. In particular, \u0026gt;an API using the typestate pattern will have:\nOperations on an object (such as methods or functions) that are only available when the object is in certain states, A way of encoding these states at the type level, such that attempts to use the operations in the wrong state fail to compile, State transition operations (methods or functions) that change the type-level state of objects in addition to, or instead of, changing run-time dynamic state, such that the operations in the previous state are no longer possible. This is useful because:\nIt moves certain types of errors from run-time to compile-time, giving programmers faster feedback. It interacts nicely with IDEs, which can avoid suggesting operations that are illegal in a certain state. It can eliminate run-time checks, making code faster/smaller. This great explanation is taken from Cliffle\u0026rsquo;s blog post \u0026ldquo;The Typestate Pattern in Rust\u0026rdquo;\nAdin(the aforementioned Embedded Rust co-worker), showed me how we can leverage this design pattern that is so easy to implement in Rust to extend the capabilities of the Rust compiler to validate your hardware configurations. My use of the Typestate pattern in the crate is heavily inspired by work done by Adin in his pursuit of creating tools to generate better HALs. Read more about Adin\u0026rsquo;s work here.\nRegisters Consider if we were to represent the hardware states within register fields as types in the Rust type system. The hardware states in the fields of registers are represented as type-states.\nType-states are marker types that directly correspond to hardware states. Hardware states are exposed as values of register bit-fields. For any type-state there is going to be a physical value that will be in the physical register. That physical value is referred to as the raw value. For any field, all of the possible hardware states it may in-habit are represented as a variant of an enum named Variant. Type-states will implement a trait named State which contains a constant VARIANT of the type Variant and value corresponding to the raw value to achieve the represented hardware state.\nConsider: A device has multiple sensors. Sensor 1 can be enabled or disabled, as well as have its measurement range changed. This chip is very picky though, and if the sensor is disabled, it\u0026rsquo;s range must be set to a specific value otherwise it exhibits undefined behaviour.\npub mod sensor_1_enable { pub trait State { const VARIANT: Variant; } #[repr(u8)] pub enum Variant { SensorEnabled = 0b0, SensorDisabled = 0b1, } pub struct SensorEnabled; pub struct SensorDisabled; impl State for SensorEnabled { const VARIANT: Variant = Variant::SensorEnabled; } impl State for SensorDisabled { const VARIANT: Variant = Variant::SensorDisabled; } } pub mod sensor_1_range { pub trait State { const VARIANT: Variant; } #[repr(u8)] pub enum Variant { RangeDisabled = 0b00, Range1 = 0b01, Range2 = 0b10, Range3 = 0b11, } pub struct RangeDisabled; pub struct Range1; pub struct Range2; pub struct Range3; impl State for RangeDisabled { const VARIANT: Variant = Variant::RangeDisabled; } impl State for Range1 { const VARIANT: Variant = Variant::Range1; } impl State for Range2 { const VARIANT: Variant = Variant::Range2; } impl State for Range3 { const VARIANT: Variant = Variant::Range1; } } Entitlements The Entitled trait is used to express inter-bit-field relationships in the type system. For example, if sensor_1_range can only be set to one of the options: {Range1, Range2, and Range3}, if sensor_1_enable is set to SensorEnabled, then one could say that the Type-States Range1, Range2, and Range3 of sensor_1_range are Entitled to the Type-State SensorEnabled of sensor_1_enable. The mandatory hardware state of the sensor range bit-field when the sensor is disabled can be enforced by the compiler using Entitlements. In code this would look like:\n// The compiler enforces that sensor 1 can only be disabled if the sensor range is set to disabled. impl Entitled\u0026lt;sensor_1_range::RangeDisabled\u0026gt; for sensor_1_enable::SensorDisabled {} // The rest of the ranges, naturally, require the sensor to be enabled. impl Entitled\u0026lt;sensor_1_enable::SensorEnabled\u0026gt; for sensor_1_range::Range1 {} impl Entitled\u0026lt;sensor_1_enable::SensorEnabled\u0026gt; for sensor_1_range::Range2 {} impl Entitled\u0026lt;sensor_1_enable::SensorEnabled\u0026gt; for sensor_1_range::Range3 {} In summary, Type-states express hardware states. The type relationships (as expressed by the Entitled trait) provide a proxy for the true hardware relationships. The resulting structures facilitate correct hardware usage.\nProperties Properties are values that are derived from multiple hardware-states of the sensor but aren\u0026rsquo;t values that are directly written to registers. Continuing on from our previous example, lets say sensor_1\u0026rsquo;s measurement resolution is derived from the sensor measurement range and a new hardware state called power_mode that is defined below:\npub mod sensor_1_power_mode { pub trait State { const VARIANT: Variant; } #[repr(u8)] pub enum Variant { LowPower = 0b0, NormalPower = 0b1, } pub struct LowPower; pub struct NormalPower; impl State for LowPower { const VARIANT: Variant = Variant::LowPower; } impl State for NormalPower { const VARIANT: Variant = Variant::NormalPower; } } Maybe the highest sensor measurement range (sensor_1_range::Range3) isn\u0026rsquo;t available when it is configured in low power mode (sensor_1_power_mode::LowPower). Again, we can tell the compiler to enforce this hardware constraint using the Entitled trait.\n// Sensor ranges 1 and 2 can be used in any power mode state. impl\u0026lt;T: sensor_1_power_mode::State\u0026gt; Entitled\u0026lt;T\u0026gt; for sensor_1_range::Range1 {} impl\u0026lt;T: sensor_1_power_mode::State\u0026gt; Entitled\u0026lt;T\u0026gt; for sensor_1_range::Range2 {} // Sensor range 3 can exclusively be used in normal power mode. impl Entitled\u0026lt;sensor_1_power_mode::NormalPower\u0026gt; for sensor_1_range::Range3 {} Then we can define the property like so:\npub mod resolution { #[derive(PartialEq)] #[repr(u8)] pub enum Variant { R8Bit = 8, R16Bit = 16, } pub trait Property { const VARIANT: Variant; } pub struct Resolution\u0026lt;R, Pm\u0026gt; where R: sensor_1_range::State, Pm: sensor_1_power_mode::State, { _p: core::marker::PhantomData\u0026lt;(R, Pm)\u0026gt;, } impl\u0026lt;R, Pm\u0026gt; Property for Resolution\u0026lt;R, Pm\u0026gt; where R: sensor_1_range::State, Pm: sensor_1_power_mode::State, { const VARIANT: Variant = { match (sensor_1_range::VARIANT, sensor_1_power_mode::VARIANT) { (sensor_1_range::Variant::Range1, sensor_1_power_mode::Variant::LowPower) =\u0026gt; Variant::R8Bit, (sensor_1_range::Variant::Range1, sensor_1_power_mode::Variant::NormalPower) =\u0026gt; Variant::R6Bit, (sensor_1_range::Variant::Range2, sensor_1_power_mode::Variant::LowPower) =\u0026gt; Variant::R8Bit, (sensor_1_range::Variant::Range2, sensor_1_power_mode::Variant::NormalPower) =\u0026gt; Variant::R16Bit, (sensor_1_range::Variant::Range3, sensor_1_power_mode::Variant::NormalPower) =\u0026gt; Variant::R16Bit, (sensor_1_range::Variant::Range3, sensor_1_power_mode::Variant::LowPower) =\u0026gt; unreachable!(), } }; } } Application I made use of the typestate API to make my driver for the lis3dh accelerometer. The lis3dh has many intertwined hardware configuration options which has caused many of the available crates to not expose these features. I can\u0026rsquo;t know for certain why features were not exposed, but to me it seems that without the typestate pattern, there isn\u0026rsquo;t a way to guarantee correct configuration of the inter-dependent features without performing several run-time checks. The typestate pattern solves this issue.\nWhile this pattern is a great way to design a safe hardware driver, it adds quite a bit more code. So you end up with the classic trade-off of quality vs. time. One important quality is guaranteed correct hardware configuration (if the driver is written correctly) which can play a major role in safety.\nWhen lives are on the line, the cost of laziness far outweighs the cost of effort. \u0026ndash; my good friend Adin\nA partial implementation of the design pattern for the lis3dh can be found in the repo below. SimonGorbot/lis3dh-driver Rust 0 0 ","date":"5 August 2025","externalUrl":null,"permalink":"/projects/lis3dh_driver/","section":"Projects","summary":"Using the typestate design pattern with Rust\u0026rsquo;s compiler to enforce proper hardware configuration.","title":"Safe Sensor Drivers Using Rust's Type System","type":"project"},{"content":"","date":"5 March 2019","externalUrl":null,"permalink":"/tags/3d-printing/","section":"Tags","summary":"","title":"3D Printing","type":"tags"},{"content":" Submission Video Background Developed at MakeUofT 2022 by myself and 3 other group members, the ‚ÄúAnti-Anti Masker Mask‚Äù was a light-hearted yet technically complex hackathon project inspired by pandemic-era distancing rules. The system combined computer vision, embedded control, and custom mechanical design to autonomously respond when an unmasked person approached within two meters. System Overview The prototype consisted of three main subsystems: mechanical, sensing and vision, and embedded control.\n1. Mechanical Design The dart launcher, loading system, and shoulder frame were custom-modeled in SolidWorks and fabricated with FDM 3D printing. Because we had no fasteners on hand, we used dovetail joints inspired by woodworking to make the assembly fully snap-fit.\nThe launcher used two brushless drone motors as flywheels, powered by a small Li-Po battery. Darts were fed into the chamber via a rack-and-pinion system driven by a servo motor. Everything was orchestrated by an Arduino Nano, which received firing commands from a laptop.\n2. Sensing and Vision A Time-of-Flight (TOF) distance sensor continuously measured the distance to the nearest person. A laptop ran an OpenCV-based vision pipeline that accessed a live camera feed, performed face detection, and identified whether the detected face was masked.\nIf an unmasked person entered a configurable ‚Äúdanger zone‚Äù (roughly 0.8 m ‚Äì 1.5 m), a command was sent via UART to the Arduino to activate the launcher.\nCode The Arduino handled motor timing, servo control, and safety interlocks. All communication between the laptop and launcher was done over serial, using a simple message protocol for distance and trigger events. We prioritized responsiveness ‚Äî latency from detection to launch averaged under 200 ms in our demo tests.\nChallenges and Adaptation Our initial plan was to run the entire system TOF sensing, computer vision, and motor control on a Raspberry Pi for a fully self-contained, battery-powered build. Reality struck when we discovered the Pi Zero couldn‚Äôt run OpenCV in real-time. It started as a miscommunication as we borrowed what we thought was going to be a Raspberry Pi 3 from a friend, but it ended up being a Pi Zero.\nWith only a few hours left, we refactored the architecture into a split system: the laptop handled sensing and vision, while the Arduino managed actuation. This quick pivot allowed us to finish with a fully functional (and crowd-pleasing) prototype by demo time.\nMore For more info on the challenges we faced, lessons we learned, and future improvements please check out the AAMM DevPost link below : https://devpost.com/software/anti-anti-masker-mask\n","date":"5 March 2019","externalUrl":null,"permalink":"/projects/aamm/","section":"Projects","summary":"A wearable system that detects nearby unmasked individuals and automatically launches soft darts to enforce social distancing. Built in 24 hours during covid.","title":"Anti-Anti Masker Mask [Hackathon: Winner]","type":"project"},{"content":"","date":"5 March 2019","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"5 March 2019","externalUrl":null,"permalink":"/tags/hackathon/","section":"Tags","summary":"","title":"Hackathon","type":"tags"},{"content":"","date":"5 March 2019","externalUrl":null,"permalink":"/tags/opencv/","section":"Tags","summary":"","title":"OpenCV","type":"tags"},{"content":"Hi I\u0026rsquo;m Simon, a senior studying Mechatronics Engineering at the University of Waterloo.\nI love working with and designing embedded systems, both the firmware and hardware.\nIn my free time I like to play volleyball, climb, drink a good coffee, spend time with my cat, and enjoy the great outdoors!\nrefresh for a new random portrait\n","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" Here are some non-technical things I want to share with the world wide web. ","externalUrl":null,"permalink":"/more/","section":"More","summary":"","title":"More","type":"more"},{"content":"Page dedicated to my Siberian cat Hobbes. He is named after the tiger from the classic comic strip Calvin and Hobbes\n","externalUrl":null,"permalink":"/more/cat/","section":"More","summary":"Some photos of my cat Hobbes.","title":"My Cat: Hobbes","type":"more"},{"content":"inser t photos\n","externalUrl":null,"permalink":"/more/photography/","section":"More","summary":"Some photos I\u0026rsquo;ve taken that I like.","title":"Photography","type":"more"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]